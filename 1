import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import ccxt
import telegram
from io import BytesIO
import config  # Import Telegram credentials from config.py

# Trendlines with Breaks class - Fixed trendline calculation
class TrendlinesWithBreaks:
    def __init__(self, length=14, mult=1.0, calc_method='stdev', backpaint=True):
        self.length = length
        self.mult = mult
        self.calc_method = calc_method.lower()
        self.backpaint = backpaint
        self.slope_ph = 0.0
        self.slope_pl = 0.0
        self.last_ph = np.nan
        self.last_pl = np.nan
        self.last_ph_idx = -1
        self.last_pl_idx = -1
        self.upper_active = False
        self.lower_active = False

    def pivot_high(self, series):
        """Calculate pivot high points"""
        pivots = pd.Series(np.nan, index=series.index)
        for i in range(self.length, len(series) - self.length):
            if (series.iloc[i] > series.iloc[i - self.length:i].max() and 
                series.iloc[i] > series.iloc[i + 1:i + self.length + 1].max()):
                pivots.iloc[i] = series.iloc[i]
        return pivots

    def pivot_low(self, series):
        """Calculate pivot low points"""
        pivots = pd.Series(np.nan, index=series.index)
        for i in range(self.length, len(series) - self.length):
            if (series.iloc[i] < series.iloc[i - self.length:i].min() and 
                series.iloc[i] < series.iloc[i + 1:i + self.length + 1].min()):
                pivots.iloc[i] = series.iloc[i]
        return pivots

    def calculate_slope(self, close):
        """Calculate slope based on selected method"""
        if self.calc_method == 'stdev':
            return close.rolling(window=self.length).std() / self.length * self.mult
        return pd.Series(np.zeros(len(close)), index=close.index)

    def check_intersection(self, upper_val, lower_val):
        """Check if upper and lower trendlines intersect"""
        if not np.isnan(upper_val) and not np.isnan(lower_val):
            return upper_val <= lower_val  # Upper trendline crosses below or equal to lower trendline
        return False

    def process(self, high, low, close):
        close = pd.Series(close, index=range(len(close)))
        high = pd.Series(high, index=range(len(high)))
        low = pd.Series(low, index=range(len(low)))
        
        # Calculate pivots
        ph = self.pivot_high(high)
        pl = self.pivot_low(low)
        slope = self.calculate_slope(close)

        # Initialize trendlines and breakout trackers
        upper_line = pd.Series(np.nan, index=close.index)
        lower_line = pd.Series(np.nan, index=close.index)
        upos = pd.Series(0, index=close.index)
        dnos = pd.Series(0, index=close.index)

        for i in range(len(close)):
            # Update pivot highs
            if not np.isnan(ph.iloc[i]) and not self.upper_active:
                self.last_ph = ph.iloc[i]
                self.last_ph_idx = i
                self.slope_ph = slope.iloc[i] if not np.isnan(slope.iloc[i]) else self.slope_ph
                self.upper_active = True

            # Update pivot lows
            if not np.isnan(pl.iloc[i]) and not self.lower_active:
                self.last_pl = pl.iloc[i]
                self.last_pl_idx = i
                self.slope_pl = slope.iloc[i] if not np.isnan(slope.iloc[i]) else self.slope_pl
                self.lower_active = True

            # Calculate trendlines
            if self.upper_active and i >= self.last_ph_idx:
                bars_since_ph = i - self.last_ph_idx
                if self.backpaint:
                    # Backpaint: calculate trendline values for past bars
                    for j in range(max(self.last_ph_idx - self.length, 0), i + 1):
                        offset = j - self.last_ph_idx
                        upper_line.iloc[j] = self.last_ph - self.slope_ph * offset
                else:
                    upper_line.iloc[i] = self.last_ph - self.slope_ph * bars_since_ph

            if self.lower_active and i >= self.last_pl_idx:
                bars_since_pl = i - self.last_pl_idx
                if self.backpaint:
                    # Backpaint: calculate trendline values for past bars
                    for j in range(max(self.last_pl_idx - self.length, 0), i + 1):
                        offset = j - self.last_pl_idx
                        lower_line.iloc[j] = self.last_pl + self.slope_pl * offset
                else:
                    lower_line.iloc[i] = self.last_pl + self.slope_pl * bars_since_pl

            # Check for intersection and reset
            if self.upper_active and self.lower_active and self.check_intersection(upper_line.iloc[i], lower_line.iloc[i]):
                self.upper_active = False
                self.lower_active = False
                self.last_ph = np.nan
                self.last_pl = np.nan
                self.last_ph_idx = -1
                self.last_pl_idx = -1
                # Clear future trendline values after intersection
                upper_line.iloc[i:] = np.nan
                lower_line.iloc[i:] = np.nan

            # Detect breaks
            if self.upper_active and not np.isnan(upper_line.iloc[i]):
                if close.iloc[i] > upper_line.iloc[i]:
                    upos.iloc[i] = 1
                    self.upper_active = False
                    self.last_ph = np.nan
                    self.last_ph_idx = -1
                    # Clear future trendline values after breakout
                    upper_line.iloc[i:] = np.nan

            if self.lower_active and not np.isnan(lower_line.iloc[i]):
                if close.iloc[i] < lower_line.iloc[i]:
                    dnos.iloc[i] = 1
                    self.lower_active = False
                    self.last_pl = np.nan
                    self.last_pl_idx = -1
                    # Clear future trendline values after breakout
                    lower_line.iloc[i:] = np.nan

        # Detect breakouts
        up_breaks = (upos.diff() > 0) & (upos == 1)
        down_breaks = (dnos.diff() > 0) & (dnos == 1)

        return {
            'upper': upper_line,
            'lower': lower_line,
            'up_breaks': up_breaks,
            'down_breaks': down_breaks
        }

async def send_to_telegram(plot_buffer):
    bot = telegram.Bot(token=config.TELEGRAM_TOKEN)
    async with bot:
        await bot.send_photo(chat_id=config.CHAT_ID, photo=plot_buffer)

def fetch_btcusdt_data():
    exchange = ccxt.binance()
    timeframe = '1h'
    limit = 100
    ohlcv = exchange.fetch_ohlcv('BTC/USDT', timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df

def create_plot(df, results):
    plt.figure(figsize=(12, 6))
    
    # Plot price
    plt.plot(df['timestamp'], df['close'], label='BTC/USDT Close', color='blue', alpha=0.7)
    
    # Plot trendlines - only where valid
    valid_upper = results['upper'][results['upper'].notna()]
    valid_lower = results['lower'][results['lower'].notna()]
    upper_times = df['timestamp'][results['upper'].notna()]
    lower_times = df['timestamp'][results['lower'].notna()]
    plt.plot(upper_times, valid_upper, label='Upper Trendline', color='teal', linestyle='--')
    plt.plot(lower_times, valid_lower, label='Lower Trendline', color='red', linestyle='--')
    
    # Plot breaks - at trendline values
    up_breaks = df[results['up_breaks']]
    down_breaks = df[results['down_breaks']]
    up_break_indices = up_breaks.index
    down_break_indices = down_breaks.index
    up_break_trendline_values = results['upper'][up_break_indices]
    down_break_trendline_values = results['lower'][down_break_indices]
    
    plt.scatter(up_breaks['timestamp'], up_break_trendline_values, 
                color='green', label='Up Break', marker='^', s=100, zorder=5)
    plt.scatter(down_breaks['timestamp'], down_break_trendline_values, 
                color='red', label='Down Break', marker='v', s=100, zorder=5)
    
    plt.title(f'BTC/USDT Trendlines with Breaks - {datetime.now().strftime("%Y-%m-%d %H:%M")}')
    plt.xlabel('Time')
    plt.ylabel('Price (USDT)')
    plt.legend(loc='best')
    plt.grid(True, alpha=0.3)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    buffer = BytesIO()
    plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
    buffer.seek(0)
    plt.close()
    return buffer

async def main():
    df = fetch_btcusdt_data()
    trendlines = TrendlinesWithBreaks(length=14, mult=1.0, calc_method='stdev', backpaint=True)
    results = trendlines.process(df['high'], df['low'], df['close'])
    plot_buffer = create_plot(df, results)
    await send_to_telegram(plot_buffer)
    plot_buffer.close()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())