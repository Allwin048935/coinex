import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, timedelta
import ccxt  # For crypto exchange data
import telegram
from io import BytesIO

# Trendlines with Breaks class (from previous response)
class TrendlinesWithBreaks:
    def __init__(self, length=14, mult=1.0, calc_method='stdev', backpaint=True):
        self.length = length
        self.mult = mult
        self.calc_method = calc_method.lower()
        self.backpaint = backpaint
        self.upper = 0.0
        self.lower = 0.0
        self.slope_ph = 0.0
        self.slope_pl = 0.0

    def pivot_high(self, series):
        return series.where(
            (series > series.shift(1)) & 
            (series > series.shift(-1)) & 
            (series > series.shift(self.length)) &
            (series > series.shift(-self.length))
        )
    
    def pivot_low(self, series):
        return series.where(
            (series < series.shift(1)) & 
            (series < series.shift(-1)) & 
            (series < series.shift(self.length)) &
            (series < series.shift(-self.length))
        )
    
    def calculate_slope(self, close):
        n = np.arange(len(close))
        if self.calc_method == 'stdev':
            return (close.rolling(window=self.length).std() / self.length * self.mult)
        return pd.Series(np.zeros(len(close)), index=close.index)
    
    def process(self, high, low, close):
        close = pd.Series(close)
        high = pd.Series(high)
        low = pd.Series(low)
        
        ph = self.pivot_high(close)
        pl = self.pivot_low(close)
        slope = self.calculate_slope(close)
        
        self.slope_ph = np.where(ph.notna(), slope, self.slope_ph)
        self.slope_pl = np.where(pl.notna(), slope, self.slope_pl)
        
        self.upper = np.where(ph.notna(), ph, self.upper - self.slope_ph)
        self.lower = np.where(pl.notna(), pl, self.lower + self.slope_pl)
        
        offset = self.length if self.backpaint else 0
        
        upper_line = self.upper if self.backpaint else self.upper - self.slope_ph * self.length
        lower_line = self.lower if self.backpaint else self.lower + self.slope_pl * self.length
        
        upos = np.where(ph.notna(), 0, 
                       np.where(close > (self.upper - self.slope_ph * self.length), 1, 0))
        dnos = np.where(pl.notna(), 0, 
                       np.where(close < (self.lower + self.slope_pl * self.length), 1, 0))
        
        up_breaks = (pd.Series(upos).diff() > 0) & (upos > 0)
        down_breaks = (pd.Series(dnos).diff() > 0) & (dnos > 0)
        
        return {
            'upper': upper_line,
            'lower': lower_line,
            'up_breaks': up_breaks,
            'down_breaks': down_breaks
        }

# Telegram configuration - REPLACE THESE WITH YOUR OWN VALUES
TELEGRAM_TOKEN = '8066951467:AAHOaFDL9kixcdwtjbwb-szDgnl8R9Vz8AI'  # Get from BotFather
CHAT_ID = '1385370555'  # Your Telegram chat ID

async def send_to_telegram(plot_buffer):
    bot = telegram.Bot(token=TELEGRAM_TOKEN)
    async with bot:
        await bot.send_photo(chat_id=CHAT_ID, photo=plot_buffer)

def fetch_btcusdt_data():
    # Initialize exchange
    exchange = ccxt.binance()
    
    # Fetch last 100 hourly candles
    timeframe = '1h'
    limit = 100
    ohlcv = exchange.fetch_ohlcv('BTC/USDT', timeframe, limit=limit)
    
    # Convert to DataFrame
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df

def create_plot(df, results):
    plt.figure(figsize=(12, 6))
    
    # Plot price
    plt.plot(df['timestamp'], df['close'], label='BTC/USDT Close', color='blue', alpha=0.5)
    
    # Plot trendlines
    plt.plot(df['timestamp'], results['upper'], label='Upper Trendline', color='teal', linestyle='--')
    plt.plot(df['timestamp'], results['lower'], label='Lower Trendline', color='red', linestyle='--')
    
    # Plot breaks
    up_breaks = df[results['up_breaks']]
    down_breaks = df[results['down_breaks']]
    plt.scatter(up_breaks['timestamp'], up_breaks['close'], color='green', label='Up Break', marker='^')
    plt.scatter(down_breaks['timestamp'], down_breaks['close'], color='red', label='Down Break', marker='v')
    
    plt.title(f'BTC/USDT Trendlines with Breaks - {datetime.now().strftime("%Y-%m-%d %H:%M")}')
    plt.xlabel('Time')
    plt.ylabel('Price (USDT)')
    plt.legend()
    plt.grid(True, alpha=0.3)
    
    # Save to buffer
    buffer = BytesIO()
    plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
    buffer.seek(0)
    plt.close()
    return buffer

async def main():
    # Fetch data
    df = fetch_btcusdt_data()
    
    # Initialize and process trendlines
    trendlines = TrendlinesWithBreaks(
        length=14,
        mult=1.0,
        calc_method='stdev',
        backpaint=True
    )
    results = trendlines.process(df['high'], df['low'], df['close'])
    
    # Create and send plot
    plot_buffer = create_plot(df, results)
    await send_to_telegram(plot_buffer)
    plot_buffer.close()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())