import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime
import ccxt
import telegram
from io import BytesIO
import config  # Import Telegram credentials from config.py

# Trendlines with Breaks class - Updated for multiple trendline sets
class TrendlinesWithBreaks:
    def __init__(self, length=14, mult=0.5, calc_method='stdev', backpaint=True):
        self.length = length
        self.mult = mult
        self.calc_method = calc_method.lower()
        self.backpaint = backpaint
        # Store multiple trendline sets as lists of (start_idx, end_idx, slope, pivot_value)
        self.upper_trendlines = []  # List of (start_idx, end_idx, slope, pivot_value)
        self.lower_trendlines = []  # List of (start_idx, end_idx, slope, pivot_value)
        self.upper_active = False
        self.lower_active = False
        self.last_ph_idx = -1
        self.last_pl_idx = -1

    def pivot_high(self, series):
        """Calculate pivot high points with improved sensitivity"""
        pivots = pd.Series(np.nan, index=series.index)
        for i in range(self.length, len(series) - self.length):
            left_max = series.iloc[i - self.length:i].max()
            right_max = series.iloc[i + 1:i + self.length + 1].max()
            if series.iloc[i] > left_max and series.iloc[i] > right_max:
                pivots.iloc[i] = series.iloc[i]
        return pivots

    def pivot_low(self, series):
        """Calculate pivot low points with improved sensitivity"""
        pivots = pd.Series(np.nan, index=series.index)
        for i in range(self.length, len(series) - self.length):
            left_min = series.iloc[i - self.length:i].min()
            right_min = series.iloc[i + 1:i + self.length + 1].min()
            if series.iloc[i] < left_min and series.iloc[i] < right_min:
                pivots.iloc[i] = series.iloc[i]
        return pivots

    def calculate_slope(self, close):
        """Calculate slope with better scaling for visuals"""
        if self.calc_method == 'stdev':
            # Use a smaller slope to make trendlines less steep and more visually appealing
            return close.rolling(window=self.length).std() / self.length * self.mult
        return pd.Series(np.zeros(len(close)), index=close.index)

    def check_intersection(self, upper_val, lower_val):
        """Check if upper and lower trendlines intersect"""
        if not np.isnan(upper_val) and not np.isnan(lower_val):
            return upper_val <= lower_val
        return False

    def process(self, high, low, close):
        close = pd.Series(close, index=range(len(close)))
        high = pd.Series(high, index=range(len(high)))
        low = pd.Series(low, index=range(len(low)))
        
        # Calculate pivots
        ph = self.pivot_high(high)
        pl = self.pivot_low(low)
        slope = self.calculate_slope(close)

        # Initialize trendlines and breakout trackers
        upper_lines = pd.Series(np.nan, index=close.index)
        lower_lines = pd.Series(np.nan, index=close.index)
        upos = pd.Series(0, index=close.index)
        dnos = pd.Series(0, index=close.index)

        for i in range(len(close)):
            # Update pivot highs
            if not np.isnan(ph.iloc[i]) and (not self.upper_active or self.last_ph_idx < i - self.length):
                self.upper_trendlines.append((i, i, slope.iloc[i], ph.iloc[i]))
                self.upper_active = True
                self.last_ph_idx = i

            # Update pivot lows
            if not np.isnan(pl.iloc[i]) and (not self.lower_active or self.last_pl_idx < i - self.length):
                self.lower_trendlines.append((i, i, slope.iloc[i], pl.iloc[i]))
                self.lower_active = True
                self.last_pl_idx = i

            # Calculate all active trendlines
            current_upper = np.nan
            current_lower = np.nan
            upper_to_remove = []
            lower_to_remove = []

            # Process upper trendlines
            for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.upper_trendlines):
                if i >= start_idx:
                    bars_since = i - start_idx
                    upper_val = pivot_val - slope_val * bars_since
                    if self.backpaint:
                        for j in range(max(start_idx - self.length, 0), i + 1):
                            offset = j - start_idx
                            upper_lines.iloc[j] = pivot_val - slope_val * offset
                    else:
                        upper_lines.iloc[i] = upper_val
                    current_upper = upper_val
                    self.upper_trendlines[idx] = (start_idx, i, slope_val, pivot_val)

            # Process lower trendlines
            for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.lower_trendlines):
                if i >= start_idx:
                    bars_since = i - start_idx
                    lower_val = pivot_val + slope_val * bars_since
                    if self.backpaint:
                        for j in range(max(start_idx - self.length, 0), i + 1):
                            offset = j - start_idx
                            lower_lines.iloc[j] = pivot_val + slope_val * offset
                    else:
                        lower_lines.iloc[i] = lower_val
                    current_lower = lower_val
                    self.lower_trendlines[idx] = (start_idx, i, slope_val, pivot_val)

            # Check for intersection and breakouts
            if self.upper_active and self.lower_active and self.check_intersection(current_upper, current_lower):
                self.upper_active = False
                self.lower_active = False
                # Stop trendlines at intersection
                for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.upper_trendlines):
                    if end_idx == i:
                        self.upper_trendlines[idx] = (start_idx, i, slope_val, pivot_val)
                        upper_lines.iloc[i:] = np.nan
                for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.lower_trendlines):
                    if end_idx == i:
                        self.lower_trendlines[idx] = (start_idx, i, slope_val, pivot_val)
                        lower_lines.iloc[i:] = np.nan

            # Detect breakouts
            if self.upper_active and not np.isnan(current_upper):
                if close.iloc[i] > current_upper:
                    upos.iloc[i] = 1
                    self.upper_active = False
                    for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.upper_trendlines):
                        if end_idx == i:
                            self.upper_trendlines[idx] = (start_idx, i, slope_val, pivot_val)
                            upper_lines.iloc[i:] = np.nan

            if self.lower_active and not np.isnan(current_lower):
                if close.iloc[i] < current_lower:
                    dnos.iloc[i] = 1
                    self.lower_active = False
                    for idx, (start_idx, end_idx, slope_val, pivot_val) in enumerate(self.lower_trendlines):
                        if end_idx == i:
                            self.lower_trendlines[idx] = (start_idx, i, slope_val, pivot_val)
                            lower_lines.iloc[i:] = np.nan

        # Detect breakouts
        up_breaks = (upos.diff() > 0) & (upos == 1)
        down_breaks = (dnos.diff() > 0) & (dnos == 1)

        return {
            'upper': upper_lines,
            'lower': lower_lines,
            'up_breaks': up_breaks,
            'down_breaks': down_breaks
        }

async def send_to_telegram(plot_buffer):
    bot = telegram.Bot(token=config.TELEGRAM_TOKEN)
    async with bot:
        await bot.send_photo(chat_id=config.CHAT_ID, photo=plot_buffer)

def fetch_btcusdt_data():
    exchange = ccxt.binance()
    timeframe = '1h'
    limit = 100
    ohlcv = exchange.fetch_ohlcv('BTC/USDT', timeframe, limit=limit)
    df = pd.DataFrame(ohlcv, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
    return df

def create_plot(df, results):
    plt.figure(figsize=(12, 6))
    
    # Plot price
    plt.plot(df['timestamp'], df['close'], label='BTC/USDT Close', color='blue', alpha=0.7)
    
    # Plot trendlines - only where valid
    valid_upper = results['upper'][results['upper'].notna()]
    valid_lower = results['lower'][results['lower'].notna()]
    upper_times = df['timestamp'][results['upper'].notna()]
    lower_times = df['timestamp'][results['lower'].notna()]
    plt.plot(upper_times, valid_upper, label='Upper Trendline', color='teal', linestyle='--')
    plt.plot(lower_times, valid_lower, label='Lower Trendline', color='red', linestyle='--')
    
    # Plot breaks - at trendline values
    up_breaks = df[results['up_breaks']]
    down_breaks = df[results['down_breaks']]
    up_break_indices = up_breaks.index
    down_break_indices = down_breaks.index
    up_break_trendline_values = results['upper'][up_break_indices]
    down_break_trendline_values = results['lower'][down_break_indices]
    
    plt.scatter(up_breaks['timestamp'], up_break_trendline_values, 
                color='green', label='Up Break', marker='^', s=100, zorder=5)
    plt.scatter(down_breaks['timestamp'], down_break_trendline_values, 
                color='red', label='Down Break', marker='v', s=100, zorder=5)
    
    plt.title(f'BTC/USDT Trendlines with Breaks - {datetime.now().strftime("%Y-%m-d %H:%M")}')
    plt.xlabel('Time')
    plt.ylabel('Price (USDT)')
    plt.legend(loc='best')
    plt.grid(True, alpha=0.3)
    plt.xticks(rotation=45)
    plt.tight_layout()
    
    buffer = BytesIO()
    plt.savefig(buffer, format='png', dpi=300, bbox_inches='tight')
    buffer.seek(0)
    plt.close()
    return buffer

async def main():
    df = fetch_btcusdt_data()
    trendlines = TrendlinesWithBreaks(length=14, mult=0.5, calc_method='stdev', backpaint=True)
    results = trendlines.process(df['high'], df['low'], df['close'])
    plot_buffer = create_plot(df, results)
    await send_to_telegram(plot_buffer)
    plot_buffer.close()

if __name__ == "__main__":
    import asyncio
    asyncio.run(main())